name: Test, Buid, Release

on:
  push:
    branches: [ "master" ]
  workflow_dispatch:

env:
  SolutionName: ${{github.event.repository.name}}
  NuGetPackageSourceCredentials_github_DKorablin: Username=${{github.actor}};Password=${{secrets.GITHUB_TOKEN}}
  DotNetVersion: 8.0.x

jobs:
  test_net_windows:
    name: Testing .NET (Windows)
    runs-on: windows-latest
    steps:
    - uses: actions/checkout@v4
      with:
        token: ${{secrets.SUBMODULE_TOKEN}}
        submodules: true
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{env.DotNetVersion}}
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        # Create a new cache when packages.lock.json changes
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
        # If the exact key doesn't exist, use the most recent cache for this OS
        restore-keys: |
          ${{ runner.os }}-nuget-
    - name: Restoring dependencies
      run: dotnet restore ${{env.SolutionName}}.sln
    - name: Testing .NET
      run: dotnet test ${{env.SolutionName}}.sln --no-build --verbosity normal

  version:
    name: Incrementing version number
    needs: [test_net_windows]
    runs-on: ubuntu-latest
    outputs:
      new_version: ${{steps.tag_version.outputs.new_version}}
      new_tag: ${{steps.tag_version.outputs.new_tag}}
      changelog: ${{steps.tag_version.outputs.changelog}}
    steps:
    - name: Updating version number
      id: tag_version
      uses: mathieudutour/github-tag-action@v6.2
      with:
        github_token: ${{secrets.GITHUB_TOKEN}}
        #custom_tag: 1.0.0

  detect_frameworks:
    name: Detecting project frameworks
    needs: [version]
    runs-on: ubuntu-latest
    outputs:
      net_framework_project_exists: ${{ steps.detect.outputs.net_framework_project_exists }}
      net_framework_project_path: ${{ steps.detect.outputs.net_framework_project_path }}
      net_framework_version: ${{ steps.detect.outputs.net_framework_version }}
      net_project_exists: ${{ steps.detect.outputs.net_project_exists }}
      net_project_path: ${{ steps.detect.outputs.net_project_path }}
      net_version: ${{ steps.detect.outputs.net_version }}
    steps:
    - uses: actions/checkout@v4
    - name: Detect project types
      id: detect
      run: |
        NET_FRAMEWORK_FOUND=false
        NET_FOUND=false
        NET_PROJECT_PATH=""
        NET_FRAMEWORK_PROJECT_PATH=""
        NET_VERSION=""
        NET_FRAMEWORK_VERSION=""
        while IFS= read -r -d '' csproj; do
          # Check for .NET Framework and capture the path and version
          if [ -z "$NET_FRAMEWORK_PROJECT_PATH" ]; then
            # This will find the first occurrence of a .NET Framework TargetFrameworkVersion and extract it
            FW_VERSION=$(grep -o -E '<TargetFrameworkVersion>v[0-9]+\.[0-9]+</TargetFrameworkVersion>' "$csproj" | head -n 1 | sed -e 's/<\/\?TargetFrameworkVersion>//g')
            if [ ! -z "$FW_VERSION" ]; then
              NET_FRAMEWORK_FOUND=true
              NET_FRAMEWORK_PROJECT_PATH=$csproj
              NET_FRAMEWORK_VERSION=$FW_VERSION
            fi
          fi
          # Check for .NET and capture the path and version
          if [ -z "$NET_PROJECT_PATH" ]; then
            # This will find the first occurrence of a .NET TargetFramework and extract it
            DOTNET_VERSION=$(grep -o -E '<TargetFramework>net[0-9]+\.[0-9]+.*</TargetFramework>' "$csproj" | head -n 1 | sed -e 's/<\/\?TargetFramework>//g')
            if [ ! -z "$DOTNET_VERSION" ]; then
              NET_FOUND=true
              NET_PROJECT_PATH=$csproj
              NET_VERSION=$DOTNET_VERSION
            fi
          fi
        done < <(find . -name "*.csproj" -print0)
        echo "net_framework_project_exists=$NET_FRAMEWORK_FOUND" >> $GITHUB_OUTPUT
        echo "net_framework_project_path=$NET_FRAMEWORK_PROJECT_PATH" >> $GITHUB_OUTPUT
        echo "net_framework_version=$NET_FRAMEWORK_VERSION" >> $GITHUB_OUTPUT
        echo "net_project_exists=$NET_FOUND" >> $GITHUB_OUTPUT
        echo "net_project_path=$NET_PROJECT_PATH" >> $GITHUB_OUTPUT
        echo "net_version=$NET_VERSION" >> $GITHUB_OUTPUT

  build_net_framework:
    name: Building .NET Framework assembly
    needs: [version,detect_frameworks]
    if: needs.detect_frameworks.outputs.net_framework_project_exists == 'true'
    runs-on: windows-latest
    steps:
    - name: Decoding SNK
      id: sign_key_file
      uses: timheuer/base64-to-file@v1.2
      with:
        fileName: 'Signature.snk'
        encodedString: ${{secrets.SIGN_ASM_KEY}}
    - uses: actions/checkout@v4
      with:
        token: ${{secrets.SUBMODULE_TOKEN}}
        submodules: true
    - name: Setup .NET
      uses: microsoft/setup-msbuild@v2
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        # Create a new cache when packages.lock.json changes
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
        # If the exact key doesn't exist, use the most recent cache for this OS
        restore-keys: |
          ${{ runner.os }}-nuget-
    - name: Restoring NuGet packages
      run: nuget restore "${{github.workspace}}\${{env.SolutionName}}.sln"
    - name: Building .NET Framework
      run: MSBuild -nologo -restore "${{github.workspace}}\${{needs.detect_frameworks.outputs.net_framework_project_path}}" -property:Configuration=Release -property:OutputPath="${{github.workspace}}/bin" -property:Version=${{needs.version.outputs.new_version}} -property:AssemblyOriginatorKeyFile="${{steps.sign_key_file.outputs.filePath}}"
    #TODO: I need to find a better approach to sign output files without explicitly specify filename and extension
    - name: Signing portable executables
      uses: dlemstra/code-sign-action@v1
      with:
        certificate: '${{secrets.SIGN_PE_CERTIFICATE}}'
        password: '${{secrets.SIGN_PE_PASSWORD}}'
        recursive: false
        files: |
          ${{github.workspace}}\bin\${{env.SolutionName}}.dll
    - name: Deploying artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{needs.detect_frameworks.outputs.net_framework_version}}
        path: ${{github.workspace}}/bin/*
        if-no-files-found: error

  build_net:
    name: Building .NET assembly
    needs: [version,detect_frameworks]
    if: needs.detect_frameworks.outputs.net_project_exists == 'true'
    runs-on: windows-latest
    steps:
    - name: Decoding SNK
      id: sign_key_file
      uses: timheuer/base64-to-file@v1.2
      with:
        fileName: 'Signature.snk'
        encodedString: ${{secrets.SIGN_ASM_KEY}}
    - uses: actions/checkout@v4
      with:
        token: ${{secrets.SUBMODULE_TOKEN}}
        submodules: true
    - name: Setup .NET
      uses: actions/setup-dotnet@v4
      with:
        dotnet-version: ${{env.DotNetVersion}}
    - name: Cache NuGet packages
      uses: actions/cache@v4
      with:
        path: ~/.nuget/packages
        # Create a new cache when packages.lock.json changes
        key: ${{ runner.os }}-nuget-${{ hashFiles('**/packages.lock.json') }}
        # If the exact key doesn't exist, use the most recent cache for this OS
        restore-keys: |
          ${{ runner.os }}-nuget-
    - name: Restoring dependencies
      run: dotnet restore ${{env.SolutionName}}.sln
    - name: Building .NET
      run: dotnet build ${{needs.detect_frameworks.outputs.net_project_path}} --configuration Release --no-restore /p:OutputPath="${{github.workspace}}/bin" /p:DocumentationFile="${{github.workspace}}/bin/${{env.SolutionName}}.xml" /p:SignAssembly=true /p:Version=${{needs.version.outputs.new_version}} /p:AssemblyOriginatorKeyFile="${{steps.sign_key_file.outputs.filePath}}"
    #TODO: I need to find a better approach to sign output files without explicitly specify filename and extension
    - name: Signing portable executables
      uses: dlemstra/code-sign-action@v1
      with:
        certificate: '${{secrets.SIGN_PE_CERTIFICATE}}'
        password: '${{secrets.SIGN_PE_PASSWORD}}'
        recursive: false
        files: |
          ${{github.workspace}}\bin\${{env.SolutionName}}.dll
    - name: Deploying artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{needs.detect_frameworks.outputs.net_version}}
        path: ${{github.workspace}}/bin/*
        if-no-files-found: error

  deploy_release:
    name: Deploying release
    needs:
      - version
      - build_net_framework
      - build_net
    if: |
        always() &&
        (needs.build_net_framework.result == 'skipped' || needs.build_net_framework.result == 'success') &&
        (needs.build_net.result == 'skipped' || needs.build_net.result == 'success')
    runs-on: ubuntu-latest
    steps:
    - name: Extracting all artifacts
      uses: actions/download-artifact@v4
      with:
        path: bin
    - name: Download and Merge Flatbed.Dialog.Lite Version
      # Fetching the latest release from the SAL host repository and merges it with current plugin release.
      run: |
        cd ${{github.workspace}}/bin
        # Get the latest release tag from the target repository
        LATEST_VERSION=$(curl -s -H "Authorization: token ${{secrets.DEPLOYMENT_TOKEN}}" "https://api.github.com/repos/DKorablin/Flatbed.Dialog.Lite/releases/latest" | jq -r .tag_name)
        
        if [ "$LATEST_VERSION" = "null" ] || [ -z "$LATEST_VERSION" ]; then
          echo "Could not find the latest release for DKorablin/Flatbed.Dialog.Lite. Skipping merge."
          exit 0
        fi
        echo "Latest Flatbed.Dialog.Lite version is $LATEST_VERSION"

        # Downloading all expected assets for specific folders
        for dir in */; do
          dir_name="${dir%/}"

          # Conditionally set the framework name for the asset because Flatbed application was built on specific versions
          if [[ $dir_name == v* ]]; then
            asset_framework_name="v3.5"
          else
            asset_framework_name="net8.0-windows"
          fi

          # Construct the expected asset name
          ASSET_NAME="Flatbed.Dialog.Lite_${LATEST_VERSION}_${dir_name}.zip"
          DOWNLOAD_URL="https://github.com/DKorablin/Flatbed.Dialog.Lite/releases/download/${LATEST_VERSION}/${ASSET_NAME}"

          echo "Checking for asset $ASSET_NAME"
          HTTP_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -L -H "Authorization: token ${{ secrets.DEPLOYMENT_TOKEN }}" "$DOWNLOAD_URL")
          
          if [ "$HTTP_STATUS" -eq 200 ]; then
            echo "Downloading asset..."
            curl -s -L -H "Authorization: token ${{ secrets.DEPLOYMENT_TOKEN }}" -H "Accept: application/octet-stream" -o "${ASSET_NAME}" "$DOWNLOAD_URL"
            echo "Successfully downloaded. Extracting to $dir_name"
            unzip -o "${ASSET_NAME}" -d "$dir_name"
            rm "${ASSET_NAME}"
          else
            echo "Warning: Could not download asset ${ASSET_NAME}. HTTP status: $HTTP_STATUS. It may not exist for this .NET version."
          fi
        done
    - name: Zipping individual artifacts
      run: |
        cd ${{github.workspace}}/bin
        for dir in */; do
          dir_name="${dir%/}"
          (cd "$dir_name" && zip -qq -r "../${{env.SolutionName}}_v${{needs.version.outputs.new_version}}_${dir_name}.zip" .)
        done
      working-directory: ${{github.workspace}}/bin
    - name: Deploying GitHub release
      uses: ncipollo/release-action@v1
      with:
        artifacts: ${{github.workspace}}/bin/*.zip
        tag: ${{needs.version.outputs.new_tag}}
        name: Auto ${{needs.version.outputs.new_tag}}
        body: ${{needs.version.outputs.changelog}}
        artifactErrorsFailBuild: true
        generateReleaseNotes: true
        token: ${{secrets.DEPLOYMENT_TOKEN}}

  deploy_nuget:
    name: Deploying NuGet package
    needs:
        - version
        - build_net_framework
        - build_net
    if: |
        always() &&
        (needs.build_net_framework.result == 'skipped' || needs.build_net_framework.result == 'success') &&
        (needs.build_net.result == 'skipped' || needs.build_net.result == 'success')
    runs-on: windows-latest

    steps:
    - name: Checkout nessesary files from repository
      uses: actions/checkout@v4
      with:
        sparse-checkout: |
          README.md
          ${{env.SolutionName}}.dll.nuspec
        sparse-checkout-cone-mode: false
    - name: Extracting all artifacts
      uses: actions/download-artifact@v4
      with:
        path: bin
    - name: Packing artifacts
      run: nuget pack ${{env.SolutionName}}.dll.nuspec -Version ${{needs.version.outputs.new_version}} -OutputDirectory nupkg
    - name: Deploying GitHub package
      run: dotnet nuget push nupkg\*.nupkg --skip-duplicate --api-key ${{secrets.GITHUB_TOKEN}} --source https://nuget.pkg.github.com/DKorablin/index.json

  failure_cleanup:
  #error: tag '${{needs.version.outputs.new_tag}}' not found.
    name: Remove version tag on failure
    needs:
      - version
      - build_net_framework
      - build_net
    if: |
      always() &&
      needs.build_net_framework.result != 'success' &&
      needs.build_net.result != 'success'
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v4
      with:
        token: ${{secrets.SUBMODULE_TOKEN}}
        submodules: false
        fetch-depth: 0 #Fetch all history for all tags and branches
    - name: Removing version tag
      run: |
        git tag -d ${{needs.version.outputs.new_tag}}
        git push origin :refs/tags/"${{needs.version.outputs.new_tag}}"